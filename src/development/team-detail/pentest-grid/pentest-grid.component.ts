import { Component, Input, OnChanges } from '@angular/core';
import {
  ParsedDevelopmentDataModel,
  PenTestFinding,
  ProductRelease,
  ProductTeam,
  SecurityRisk,
} from '../../../shared';
import { Observable, filter, map } from 'rxjs';
import { DevelopmentFilterService } from '../../../analyzation/filter/development-filter.service';
import { sortByDate } from '../../../utils/array.utils';
import { DateTime } from 'luxon';
import { ParsedDataService } from '../../../normalization';

export type SeverityCategory = 'Low' | 'Medium' | 'High' | 'Critical';

export type AugmentedPenTestFinding = PenTestFinding & {
  cat: SeverityCategory;
  risks: SecurityRisk[];
};

@Component({
  selector: 'app-pentest-grid',
  templateUrl: './pentest-grid.component.html',
  styleUrls: ['./pentest-grid.component.scss'],
})
export class PentestGridComponent implements OnChanges {
  @Input()
  product: ProductTeam | undefined;

  filteredData$: Observable<ParsedDevelopmentDataModel>;

  findings$: Observable<AugmentedPenTestFinding[]> | undefined;

  developmentData$: Observable<ParsedDevelopmentDataModel>;

  isDateFiltered$: Observable<boolean>;

  constructor(
    filterService: DevelopmentFilterService,
    private readonly parsedDataService: ParsedDataService
  ) {
    this.filteredData$ = filterService.filteredData$;

    this.developmentData$ = parsedDataService
      .getParsedDevelopmentData$()
      .pipe(filter((data): data is ParsedDevelopmentDataModel => !!data));

    this.isDateFiltered$ = filterService.currentFilter$.pipe(
      map((filter) => {
        const date = filter?.snapshotDate;
        if (!date) {
          return false;
        }

        // Day implies year and month
        return !DateTime.now().hasSame(DateTime.fromJSDate(date), 'day');
      })
    );
  }

  ngOnChanges() {
    if (this.product) {
      const product = this.product;

      this.findings$ = this.filteredData$.pipe(
        map((data: ParsedDevelopmentDataModel) => {
          const sortedReleases = sortByDate(
            data.productReleases.filter((it) => it.productId === product.id),
            (it) => it.releaseDate
          );

          const mostRecentRelease = sortedReleases[sortedReleases.length - 1];
          return this.getEntries(data, mostRecentRelease);
        })
      );
    }
  }

  getEntries(
    data: ParsedDevelopmentDataModel,
    release: ProductRelease
  ): AugmentedPenTestFinding[] {
    const matchingEntries = data.penTestFindings
      .map((x, i) => ({ ...x, ogIndex: i }))
      .filter((entry) => entry.releaseId === release.id);

    const augmented: AugmentedPenTestFinding[] = matchingEntries.map((p) => ({
      ...p,
      cat: this.getCat(p.severity),
      risks: data.securityRisks.filter((x) => p.riskIds.includes(x.id)),
    }));

    return augmented.sort((a, b) => b.severity - a.severity);
  }

  getCat(sev: number): SeverityCategory {
    if (sev < 3) {
      return 'Low';
    }
    if (sev >= 3 && sev < 6) {
      return 'Medium';
    }
    if (sev >= 6 && sev < 9) {
      return 'High';
    }
    if (sev >= 9) {
      return 'Critical';
    }
    return 'Low';
  }

  onResolveClick(ogIndex: number, data: ParsedDevelopmentDataModel) {
    if (!this.product) {
      return;
    }

    const newPenTestFindings: PenTestFinding[] = data.penTestFindings.map(
      (p, index) =>
        index !== ogIndex
          ? p
          : { ...p, ignored: true, resolvedDate: new Date() }
    );

    data = { ...data, penTestFindings: newPenTestFindings };

    this.parsedDataService.setParsedDevelopmentData$({ ...data });
  }
}
