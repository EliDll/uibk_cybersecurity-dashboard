import { Injectable } from '@angular/core';
import { ChartData, ChartType } from 'chart.js';
import { DevelopmentFilterService } from 'src/analyzation/filter/development-filter.service';
import {
  AbstractResourceChartConfiguration,
  ChartColor,
  ResourceData,
  getColorWithOpacity,
} from 'src/chart';
import { ParsedDevelopmentDataModel, ProductTeam } from 'src/shared';
import { RouteData } from 'src/shared/util/routes';
import { sortByDate } from 'src/utils/array.utils';

@Injectable({
  providedIn: 'root',
})
export class PentestDistributionChartConfiguration extends AbstractResourceChartConfiguration<
  ParsedDevelopmentDataModel,
  ProductTeam,
  'pie'
> {
  override chartTitle = 'Current release Mitigation progress';
  override chartLegend = true;
  override chartType: ChartType = 'pie';
  override chartOptions = {
    responsive: true,
  };
  override dataSource$ = this.filterService.filteredData$;

  constructor(private readonly filterService: DevelopmentFilterService) {
    super(RouteData.CURRENT_TEAM);
  }

  protected override collectChartData(
    data: ResourceData<ParsedDevelopmentDataModel, ProductTeam>
  ): ChartData<'pie'> {
    const sortedReleases = sortByDate(
      data.data.productReleases.filter(
        (it) => it.productId === data.resource.id
      ),
      (it) => it.releaseDate
    );

    const mostRecentRelease = sortedReleases[sortedReleases.length - 1];
    if (sortedReleases.length === 0) {
      return {
        datasets: [],
      };
    }

    const labels = ['Mitigated', 'Resolved manually', 'Open'];

    const penTestFindings = data.data.penTestFindings.filter(
      (p) => p.releaseId === mostRecentRelease.id
    );

    const mitigated = penTestFindings.filter(
      (p) => p.ignored === false && p.resolvedDate
    );
    const resolved = penTestFindings.filter(
      (p) => p.ignored === true && p.resolvedDate
    );
    const open = penTestFindings.filter((p) => !p.resolvedDate);

    return {
      labels: labels,
      datasets: [
        {
          data: [mitigated.length, resolved.length, open.length],
          borderColor: [
            ChartColor.BURGUNDY,
            ChartColor.WARM_CONCRETE,
            ChartColor.HILTI_RED,
          ],
          backgroundColor: [
            getColorWithOpacity(ChartColor.BURGUNDY, 0.5),
            getColorWithOpacity(ChartColor.WARM_CONCRETE, 0.5),
            getColorWithOpacity(ChartColor.HILTI_RED, 0.5),
          ],
        },
      ],
    };
  }
}
